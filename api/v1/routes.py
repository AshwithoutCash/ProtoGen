from fastapi import FastAPI
from pydantic import BaseModel, Field
from typing import Optional

app = FastAPI()

class RouteGenRequest(BaseModel):
    overarching_goal: str = Field(..., min_length=10)
    starting_material: str = Field(..., min_length=3)
    target_organism: str = Field(..., min_length=2)
    constraints: Optional[str] = None
    llm_provider: str = Field("gemini")

class RouteGenResponse(BaseModel):
    success: bool
    routes: str
    provider_used: str
    error: Optional[str] = None

@app.get("/")
async def info():
    return {
        "message": "Route-Gen endpoint is ready. Use POST to generate routes.",
        "post": "/api/v1/routes"
    }

@app.post("/")
async def generate_routes(req: RouteGenRequest) -> RouteGenResponse:
    # Minimal mock response to verify routing in Vercel
    routes_md = f"""# ðŸ§­ Route-Gen: Candidate Experimental Routes

## Project Goal
{req.overarching_goal}

## Route A: Standard Approach
- Uses starting material: {req.starting_material}
- Target organism/system: {req.target_organism}
- Steps:
  1. Prepare inputs
  2. Execute core technique
  3. Validate outcome

## Route B: Alternative Approach
- Optimized for constraints: {req.constraints or 'None specified'}
- Steps:
  1. Use simplified reagents
  2. Shortened workflow
  3. Rapid validation

---
Generated by Proto-Gen (mock on Vercel).
"""
    return RouteGenResponse(success=True, routes=routes_md, provider_used=req.llm_provider)
