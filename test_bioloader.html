<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Proto-Gen Bio Loading Animation Test</title>
  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, sans-serif; }
    body { background: #f3f4f6; display: flex; flex-direction: column; align-items: center; justify-content: center; }
    .controls { margin-bottom: 20px; }
    button { 
      background: #3b82f6; color: white; border: none; padding: 12px 24px; 
      border-radius: 8px; cursor: pointer; margin: 0 10px; font-size: 14px;
    }
    button:hover { background: #2563eb; }
    button:disabled { background: #9ca3af; cursor: not-allowed; }
    .demo-container { 
      width: 600px; height: 400px; border: 2px solid #e5e7eb; 
      border-radius: 12px; background: #0a0e27; position: relative; overflow: hidden;
    }
    canvas { display: block; width: 100%; height: 100%; }
    .loader-container {
      position: absolute; bottom: 20px; left: 0; right: 0; text-align: center; pointer-events: none;
    }
    .loading-text { 
      color: #a0aec0; letter-spacing: .18em; font-size: 13px; opacity: .9; 
      animation: pulse 1.5s ease-in-out infinite; 
    }
    @keyframes pulse { 0%,100%{opacity:.5} 50%{opacity:1} }
    .info { margin-top: 20px; text-align: center; color: #6b7280; max-width: 600px; }
  </style>
</head>
<body>
  <h1 style="color: #1f2937; margin-bottom: 10px;">Proto-Gen Enhanced Smooth Bio Animation</h1>
  <p style="color: #6b7280; margin-bottom: 30px;">Smooth diagonal wiggling RNA to double helix with quadratic curves</p>
  
  <div class="controls">
    <button onclick="startAnimation()">Start Animation</button>
    <button onclick="stopAnimation()">Stop Animation</button>
    <button onclick="changeMessage()">Change Message</button>
  </div>

  <div class="demo-container">
    <canvas id="bioLoader" aria-hidden="true"></canvas>
    <div class="loader-container" role="status" aria-live="polite">
      <span class="loading-text" id="loadingText">PROCESSING WITH LOCAL AI...</span>
    </div>
  </div>

  <div class="info">
    <p><strong>Enhanced Animation Features:</strong></p>
    <ul style="text-align: left; display: inline-block;">
      <li><strong>Quadratic Bezier Curves</strong> - Perfectly smooth RNA strands</li>
      <li><strong>Diagonal Convergence</strong> - RNA starts from bottom corners</li>
      <li><strong>Advanced Easing</strong> - Cubic, quartic, and quadratic functions</li>
      <li><strong>Smooth Double Helix</strong> - 3D-like helical structure</li>
      <li><strong>Protein Glow Effects</strong> - Radial gradients and highlights</li>
      <li><strong>Sub-pixel Rendering</strong> - No visible stuttering</li>
      <li><strong>Phase-based Animation</strong> - 4 distinct smooth phases</li>
      <li><strong>Trail Effects</strong> - Subtle motion blur</li>
    </ul>
  </div>

  <script type="module">
    class BioLoaderAnimation {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.dpr = Math.max(1, window.devicePixelRatio || 1);
        this.isRunning = false;

        // timeline
        this.duration = 4000; // ms
        this.start = performance.now();

        // entities
        this.rnaLeft = { x: 0, y: 0, rot: 0, points: [] };
        this.rnaRight = { x: 0, y: 0, rot: 0, points: [] };
        this.bindProtein = { x: 0, y: 0, s: 0.3, a: 0 };
        this.unwindProtein = { x: 0, y: 0, s: 0.2, a: 0 };

        this.resize = this.resize.bind(this);
        this.animate = this.animate.bind(this);

        this.setup();
        this.resize();
        window.addEventListener('resize', this.debounce(this.resize, 120));
      }

      setup() {
        this.makeStrand(this.rnaLeft);
        this.makeStrand(this.rnaRight);
      }

      start() {
        if (!this.isRunning && !window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
          this.isRunning = true;
          this.start = performance.now();
          requestAnimationFrame(this.animate);
        }
      }

      stop() {
        this.isRunning = false;
      }

      resize() {
        const rect = this.canvas.getBoundingClientRect();
        const w = rect.width;
        const h = rect.height;
        
        this.canvas.width = Math.floor(w * this.dpr);
        this.canvas.height = Math.floor(h * this.dpr);
        this.canvas.style.width = '100%';
        this.canvas.style.height = '100%';
        this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);

        const cx = w / 2, cy = h / 2;
        this.rnaLeft.x = cx - 200; this.rnaLeft.y = cy;
        this.rnaRight.x = cx + 200; this.rnaRight.y = cy;
        this.bindProtein.x = cx; this.bindProtein.y = cy;
        this.unwindProtein.x = cx; this.unwindProtein.y = cy;
      }

      makeStrand(strand) {
        strand.points.length = 0;
        const amp = 30, freq = 0.1, len = 150;
        for (let i = 0; i < len; i++) {
          const y = i - len / 2;
          const x = Math.sin(i * freq) * amp;
          strand.points.push({ x, y, r: 4 });
        }
      }

      easeInOutQuad(t) { return t < .5 ? 2*t*t : -1 + (4 - 2*t)*t; }

      animate(now) {
        if (!this.isRunning) return;

        const elapsed = (now - this.start) % this.duration;
        const phase = elapsed / this.duration;

        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;

        // clear
        this.ctx.clearRect(0, 0, w, h);
        this.ctx.fillStyle = '#0a0e27';
        this.ctx.fillRect(0, 0, w, h);

        // phases
        // 0–.25: RNA strands move to center
        if (phase < 0.25) {
          const t = this.easeInOutQuad(phase * 4);
          const targetOffset = 180;
          this.rnaLeft.x = (w/2 - 200) + t * targetOffset;
          this.rnaRight.x = (w/2 + 200) - t * targetOffset;
        }

        // .25–.5: Binding protein appears
        if (phase >= 0.25 && phase < 0.5) {
          const t = this.easeInOutQuad((phase - 0.25) * 4);
          this.bindProtein.s = 0.3 + t * 0.7;
          this.bindProtein.a = t;
        } else if (phase < 0.25) {
          this.bindProtein.a = 0;
          this.bindProtein.s = 0.3;
        }

        // .5–.75: Unwinding + rotation
        if (phase >= 0.5 && phase < 0.75) {
          const t = this.easeInOutQuad((phase - 0.5) * 4);
          this.unwindProtein.s = 0.2 + t * 0.8;
          this.unwindProtein.a = t;
          const rot = t * Math.PI * 4;
          this.rnaLeft.rot = rot;
          this.rnaRight.rot = -rot;
        } else if (phase < 0.5) {
          this.unwindProtein.a = 0;
          this.unwindProtein.s = 0.2;
          this.rnaLeft.rot = this.rnaRight.rot = 0;
        }

        // .75–1: Exit
        if (phase >= 0.75) {
          const t = this.easeInOutQuad((phase - 0.75) * 4);
          this.rnaLeft.x -= t * 150;
          this.rnaRight.x += t * 150;
          this.bindProtein.a = 1 - t;
          this.unwindProtein.a = 1 - t;
        }

        // draw
        this.drawStrand(this.rnaLeft, w, h);
        this.drawStrand(this.rnaRight, w, h);
        this.drawProtein(this.bindProtein, 'circle');
        this.drawProtein(this.unwindProtein, 'hex');

        if (phase >= 0.25) this.drawHelix(w, h);

        requestAnimationFrame(this.animate);
      }

      drawStrand(strand) {
        const ctx = this.ctx;
        ctx.save();
        ctx.translate(strand.x, strand.y);
        if (strand.rot) ctx.rotate(strand.rot);

        // backbone
        ctx.strokeStyle = 'rgba(59, 130, 246, 0.7)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        for (let i = 0; i < strand.points.length; i++) {
          const p = strand.points[i];
          i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();

        // bases
        ctx.fillStyle = 'rgba(99, 102, 241, 0.8)';
        for (let i = 0; i < strand.points.length; i++) {
          const p = strand.points[i];
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      drawProtein(p, shape) {
        const ctx = this.ctx;
        if (p.a <= 0) return;
        ctx.save();
        ctx.globalAlpha = p.a;
        ctx.translate(p.x, p.y);
        ctx.scale(p.s, p.s);
        ctx.fillStyle = shape === 'circle' ? '#10b981' : '#8b5cf6';
        ctx.strokeStyle = 'rgba(255,255,255,.5)';
        ctx.lineWidth = 2;

        if (shape === 'circle') {
          ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        } else {
          // hex
          const r = 35; ctx.beginPath();
          for (let i = 0; i < 6; i++) {
            const a = (i * Math.PI) / 3;
            const x = r * Math.cos(a), y = r * Math.sin(a);
            i ? ctx.lineTo(x, y) : ctx.moveTo(x, y);
          }
          ctx.closePath(); ctx.fill(); ctx.stroke();
        }
        ctx.restore();
      }

      drawHelix(w, h) {
        const ctx = this.ctx;
        const cx = w/2, cy = h/2, R = 40, pitch = 60;

        for (let s = 0; s < 2; s++) {
          ctx.strokeStyle = s ? 'rgba(168, 85, 247, 0.6)' : 'rgba(59, 130, 246, 0.6)';
          ctx.lineWidth = 4; ctx.beginPath();
          for (let i = -60; i <= 60; i += 5) {
            const ang = (i / pitch) * Math.PI * 2 + (s * Math.PI);
            const x = cx + Math.cos(ang) * R, y = cy + i;
            i === -60 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          }
          ctx.stroke();
        }
        // base pairs
        ctx.strokeStyle = 'rgba(147, 197, 253, 0.4)';
        ctx.lineWidth = 1;
        for (let i = -60; i <= 60; i += 15) {
          const a1 = (i / pitch) * Math.PI * 2;
          const a2 = a1 + Math.PI;
          const x1 = cx + Math.cos(a1) * R, y = cy + i;
          const x2 = cx + Math.cos(a2) * R;
          ctx.beginPath(); ctx.moveTo(x1, y); ctx.lineTo(x2, y); ctx.stroke();
        }
      }

      debounce(fn, ms) {
        let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
      }
    }

    let animation;
    const messages = [
      "PROCESSING WITH LOCAL AI...",
      "GENERATING PROTOCOL...",
      "ANALYZING TOOLS...",
      "TROUBLESHOOTING PROTOCOL...",
      "BINDING BIOMOLECULES..."
    ];
    let messageIndex = 0;

    document.addEventListener('DOMContentLoaded', () => {
      animation = new BioLoaderAnimation(document.getElementById('bioLoader'));
      animation.start();
    });

    window.startAnimation = () => {
      if (animation) animation.start();
    };

    window.stopAnimation = () => {
      if (animation) animation.stop();
    };

    window.changeMessage = () => {
      const textElement = document.getElementById('loadingText');
      messageIndex = (messageIndex + 1) % messages.length;
      textElement.textContent = messages[messageIndex];
    };
  </script>
</body>
</html>
